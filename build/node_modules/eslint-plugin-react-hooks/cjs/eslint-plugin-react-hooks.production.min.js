/** @license React vundefined
 * eslint-plugin-react-hooks.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';function T(a){return"Identifier"===a.type?/^use[A-Z0-9].*$/.test(a.name):"MemberExpression"===a.type&&!a.computed&&T(a.property)?(a=a.object,"Identifier"===a.type&&"React"===a.name):!1}function aa(a){return"Identifier"===a.type?!/^[a-z]/.test(a.name):!1}function ca(a,c){return a.name===c||"MemberExpression"===a.type&&"React"===a.object.name&&a.property.name===c}function da(a){return!!(a.parent&&a.parent.callee&&ca(a.parent.callee,"forwardRef"))}
function ha(a){return!!(a.parent&&a.parent.callee&&ca(a.parent.callee,"memo"))}function ia(a){for(;a;){var c=ja(a);if(c&&(aa(c)||T(c))||da(a)||ha(a))return!0;a=a.parent}return!1}
function ja(a){if("FunctionDeclaration"===a.type||"FunctionExpression"===a.type&&a.id)return a.id;if("FunctionExpression"===a.type||"ArrowFunctionExpression"===a.type)return"VariableDeclarator"===a.parent.type&&a.parent.init===a?a.parent.id:"AssignmentExpression"===a.parent.type&&a.parent.right===a&&"="===a.parent.operator?a.parent.left:"Property"!==a.parent.type||a.parent.value!==a||a.parent.computed?"AssignmentPattern"!==a.parent.type||a.parent.right!==a||a.parent.computed?void 0:a.parent.left:
a.parent.key}
function ka(a){function c(){return{isRequired:!1,isSatisfiedRecursively:!1,hasRequiredNodesBelow:!1,children:new Map}}function e(a,d){d=d.split(".");var l=!0,b=!1,h=void 0;try{for(var g=d[Symbol.iterator](),e;!(l=(e=g.next()).done);l=!0){var C=e.value,r=a.children.get(C);r||(r=c(),a.children.set(C,r));a=r}}catch(G){b=!0,h=G}finally{try{l||null==g.return||g.return()}finally{if(b)throw h;}}return a}function g(a,c,d){c=c.split(".");var b=!0,l=!1,g=void 0;try{for(var e=c[Symbol.iterator](),h;!(b=
(h=e.next()).done);b=!0){var r=a.children.get(h.value);if(!r)break;d(r);a=r}}catch(G){l=!0,g=G}finally{try{b||null==e.return||e.return()}finally{if(l)throw g;}}}function b(a,c,d,g){a.children.forEach(function(a,l){var e=g(l);a.isSatisfiedRecursively?a.hasRequiredNodesBelow&&d.add(e):a.isRequired?c.add(e):b(a,c,d,function(a){return e+"."+a})})}var H=a.dependencies,k=a.declaredDependencies,n=a.optionalDependencies,v=a.externalDependencies,z=a.isEffect,I=c();H.forEach(function(a,c){e(I,c).isRequired=
!0;g(I,c,function(a){a.hasRequiredNodesBelow=!0})});k.forEach(function(a){e(I,a.key).isSatisfiedRecursively=!0});n.forEach(function(a){e(I,a).isSatisfiedRecursively=!0});a=new Set;var d=new Set;b(I,a,d,function(a){return a});var r=[],C=new Set,D=new Set;k.forEach(function(a){a=a.key;d.has(a)?-1===r.indexOf(a)?r.push(a):D.add(a):!z||a.endsWith(".current")||v.has(a)?C.add(a):-1===r.indexOf(a)&&r.push(a)});a.forEach(function(a){r.push(a)});return{suggestedDependencies:r,unnecessaryDependencies:C,duplicateDependencies:D,
missingDependencies:a}}
function la(a){var c=a.declaredDependenciesNode,e=a.componentScope,g=a.scope;return a.declaredDependencies.map(function(a){a=e.set.get(a.key);if(null==a)return null;var c=a.defs[0];return null==c?null:"Variable"===c.type&&"VariableDeclarator"===c.node.type&&null!=c.node.init&&("ArrowFunctionExpression"===c.node.init.type||"FunctionExpression"===c.node.init.type)||"FunctionName"===c.type&&"FunctionDeclaration"===c.node.type?a:null}).filter(Boolean).map(function(a){var e=a.defs[0];a:{for(var b=!1,n=
0;n<a.references.length;n++){var v=a.references[n];if(v.writeExpr)if(b){a=!0;break a}else{b=!0;continue}for(var z=v.from;z!==g&&null!=z;)z=z.upper;if(z!==g&&!ma(c,v.identifier)){a=!0;break a}}a=!1}return{fn:e,suggestUseCallback:a}})}function na(a){return"MemberExpression"!==a.parent.type||a.parent.object!==a||"current"===a.parent.property.name||a.parent.computed||null!=a.parent.parent&&"CallExpression"===a.parent.parent.type&&a.parent.parent.callee===a.parent?a:na(a.parent)}
function Y(a){if("Identifier"===a.type)return a.name;if("MemberExpression"!==a.type||a.computed)throw Error("Unsupported node type: "+a.type);var c=Y(a.object);a=Y(a.property);return c+"."+a}function oa(a){return"MemberExpression"!==a.type||"Identifier"!==a.object.type||"React"!==a.object.name||"Identifier"!==a.property.type||a.computed?a:a.property}
function pa(a,c){var e=oa(a);if("Identifier"!==e.type)return-1;switch(e.name){case "useEffect":case "useLayoutEffect":case "useCallback":case "useMemo":return 0;case "useImperativeHandle":return 1;default:if(e===a&&c&&c.additionalHooks){try{var g=Y(e)}catch(b){if(/Unsupported node type/.test(b.message))return 0;throw b;}return c.additionalHooks.test(g)?0:-1}return-1}}
function qa(a,c){for(var e=[a],g=null;e.length;){g=e.shift();if("Identifier"===g.type&&g.name===c.name&&g.range[0]===c.range[0]&&g.range[1]===c.range[1])return g;if(ma(g,c)){a=0;for(var b=Object.entries(g);a<b.length;a++){var H=b[a],k=H[1];"parent"!==H[0]&&(ra(k)?(k.parent=g,e.push(k)):Array.isArray(k)&&k.forEach(function(a){ra(a)&&(a.parent=g,e.push(a))}))}}}return null}
function sa(a){for(var c="",e=0;e<a.length;e++)c+=a[e],0===e&&2===a.length?c+=" and ":e===a.length-2&&2<a.length?c+=", and ":e<a.length-1&&(c+=", ");return c}function ra(a){return"object"===typeof a&&null!==a&&!Array.isArray(a)&&"string"===typeof a.type}function ma(a,c){return a.range[0]<=c.range[0]&&a.range[1]>=c.range[1]}exports.configs={recommended:{plugins:["react-hooks"],rules:{"react-hooks/rules-of-hooks":"error","react-hooks/exhaustive-deps":"warn"}}};
exports.rules={"rules-of-hooks":{create:function(a){var c=[],e=[];return{onCodePathSegmentStart:function(a){return e.push(a)},onCodePathSegmentEnd:function(){return e.pop()},onCodePathStart:function(){return c.push(new Map)},onCodePathEnd:function(e,b){function g(a,c){var d=g.cache,b=d.get(a.id);c=new Set(c);if(c.has(a.id)){d=[].concat(c);a=d.slice(d.indexOf(a.id)+1);d=!0;b=!1;var f=void 0;try{for(var w=a[Symbol.iterator](),x;!(d=(x=w.next()).done);d=!0)z.add(x.value)}catch(J){b=!0,f=J}finally{try{d||
null==w.return||w.return()}finally{if(b)throw f;}}return 0}c.add(a.id);if(void 0!==b)return b;if(e.thrownSegments.includes(a))b=0;else if(0===a.prevSegments.length)b=1;else{b=0;w=!0;x=!1;var L=void 0;try{f=a.prevSegments[Symbol.iterator]();for(var V;!(w=(V=f.next()).done);w=!0)b+=g(V.value,c)}catch(J){x=!0,L=J}finally{try{w||null==f.return||f.return()}finally{if(x)throw L;}}}a.reachable&&0===b?d.delete(a.id):d.set(a.id,b);return b}function k(a,c){var d=k.cache,b=d.get(a.id);c=new Set(c);if(c.has(a.id)){d=
Array.from(c);a=d.slice(d.indexOf(a.id)+1);d=!0;b=!1;var f=void 0;try{for(var w=a[Symbol.iterator](),x;!(d=(x=w.next()).done);d=!0)z.add(x.value)}catch(J){b=!0,f=J}finally{try{d||null==w.return||w.return()}finally{if(b)throw f;}}return 0}c.add(a.id);if(void 0!==b)return b;if(e.thrownSegments.includes(a))b=0;else if(0===a.nextSegments.length)b=1;else{b=0;w=!0;x=!1;var L=void 0;try{f=a.nextSegments[Symbol.iterator]();for(var g;!(w=(g=f.next()).done);w=!0)b+=k(g.value,c)}catch(J){x=!0,L=J}finally{try{w||
null==f.return||f.return()}finally{if(x)throw L;}}}d.set(a.id,b);return b}function n(a){var c=n.cache,d=c.get(a.id);if(null===d)return Infinity;if(void 0!==d)return d;c.set(a.id,null);if(0===a.prevSegments.length)d=1;else{d=Infinity;var b=!0,f=!1,w=void 0;try{for(var x=a.prevSegments[Symbol.iterator](),L;!(b=(L=x.next()).done);b=!0){var e=n(L.value);e<d&&(d=e)}}catch(J){f=!0,w=J}finally{try{b||null==x.return||x.return()}finally{if(f)throw w;}}d+=1}c.set(a.id,d);return d}var v=c.pop();if(0!==v.size){var z=
new Set;g.cache=new Map;k.cache=new Map;n.cache=new Map;var I=k(e.initialSegment),d=ja(b),r=ia(b),C=d?aa(d)||T(d):da(b)||ha(b),D=Infinity,l=!0,h=!1,A=void 0;try{for(var p=e.finalSegments[Symbol.iterator](),S;!(l=(S=p.next()).done);l=!0){var B=S.value;if(B.reachable){var q=n(B);q<D&&(D=q)}}}catch(F){h=!0,A=F}finally{try{l||null==p.return||p.return()}finally{if(h)throw A;}}l=!0;h=!1;A=void 0;try{for(var ba=v[Symbol.iterator](),Z;!(l=(Z=ba.next()).done);l=!0){var G=Z.value,t=G[0],W=G[1];if(t.reachable){var P=
0===t.nextSegments.length?D<=n(t):D<n(t),N=g(t)*k(t),M=z.has(t.id);v=!0;p=!1;S=void 0;try{for(var m=W[Symbol.iterator](),E;!(v=(E=m.next()).done);v=!0){var y=E.value;M&&a.report({node:y,message:'React Hook "'+a.getSource(y)+'" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'});if(C){if(!M&&N!==I){var Q='React Hook "'+a.getSource(y)+'" is called conditionally. React Hooks must be called in the exact same order in every component render.'+
(P?" Did you accidentally call a React Hook after an early return?":"");a.report({node:y,message:Q})}}else if(b.parent&&("MethodDefinition"===b.parent.type||"ClassProperty"===b.parent.type)&&b.parent.value===b){var R='React Hook "'+a.getSource(y)+'" cannot be called in a class component. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:y,message:R})}else if(d){var K='React Hook "'+a.getSource(y)+'" is called in function "'+(a.getSource(d)+'" that is neither a React function component nor a custom React Hook function.');
a.report({node:y,message:K})}else if("Program"===b.type){var X='React Hook "'+a.getSource(y)+'" cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:y,message:X})}else if(r){var O='React Hook "'+a.getSource(y)+'" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:y,message:O})}}}catch(F){p=!0,S=F}finally{try{v||null==m.return||
m.return()}finally{if(p)throw S;}}}}}catch(F){h=!0,A=F}finally{try{l||null==ba.return||ba.return()}finally{if(h)throw A;}}}},CallExpression:function(a){if(T(a.callee)){var b=c[c.length-1],g=e[e.length-1],k=b.get(g);k||(k=[],b.set(g,k));k.push(a.callee)}}}}},"exhaustive-deps":{meta:{fixable:"code",schema:[{type:"object",additionalProperties:!1,enableDangerousAutofixThisMayCauseInfiniteLoops:!1,properties:{additionalHooks:{type:"string"},enableDangerousAutofixThisMayCauseInfiniteLoops:{type:"boolean"}}}]},
create:function(a){function c(c){b&&Array.isArray(c.suggest)&&0<c.suggest.length&&(c.fix=c.suggest[0].fix);a.report(c)}function e(a,c){return function(d){if(c.has(d))return c.get(d);var b=a(d);c.set(d,b);return b}}function g(d,b,g){function r(a){var f=!0,c=!1,b=void 0;try{for(var g=a.references[Symbol.iterator](),e;!(f=(e=g.next()).done);f=!0){var h=e.value;if(h.resolved&&C.has(h.resolved.scope)){var l=qa(d,h.identifier),k=na(l),m=Y(k),p;if(p=A&&"Identifier"===k.type&&"MemberExpression"===k.parent.type&&
!k.parent.computed&&"Identifier"===k.parent.property.type&&"current"===k.parent.property.name){for(var n=h.from,u=!1;n.block!==d;)"function"===n.type&&(u=null!=n.block.parent&&"ReturnStatement"===n.block.parent.type),n=n.upper;p=u}p&&G.set(m,{reference:h,dependencyNode:k});var q=h.resolved.defs[0];if(null!=q&&(null==q.node||q.node.init!==d.parent)&&"TypeParameter"!==q.type)if(t.has(m))t.get(m).references.push(h);else{var v=h.resolved,y=H(v)||Z(v);t.set(m,{isStatic:y,references:[h]})}}}}catch(fa){c=
!0,b=fa}finally{try{f||null==g.return||g.return()}finally{if(c)throw b;}}f=!0;c=!1;b=void 0;try{for(var D=a.childScopes[Symbol.iterator](),z;!(f=(z=D.next()).done);f=!0)r(z.value)}catch(fa){c=!0,b=fa}finally{try{f||null==D.return||D.return()}finally{if(c)throw b;}}}function l(a,c,x,b){return 0===a.size?null:(1<a.size?"":c+" ")+x+" "+(1<a.size?"dependencies":"dependency")+": "+sa(Array.from(a).sort().map(function(a){return"'"+a+"'"}))+(". Either "+b+" "+(1<a.size?"them":"it")+" or remove the dependency array.")}
var h=oa(g).name,A=/Effect($|[^a-z])/g.test(h);if(b||A){A&&d.async&&c({node:d,message:"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching"});for(var p=
k.acquire(d),C=new Set,B=null,q=p.upper;q;){C.add(q);if("function"===q.type)break;q=q.upper}if(q){B=q;var H=e(function(a){if(!Array.isArray(a.defs))return!1;var c=a.defs[0];if(null==c||"VariableDeclarator"!==c.node.type)return!1;var f=c.node.init;if(null==f)return!1;var b=c.node.parent;if(null==b&&(qa(B.block,c.node.id),b=c.node.parent,null==b))return!1;if("const"===b.kind&&"Literal"===f.type&&("string"===typeof f.value||"number"===typeof f.value||null===f.value))return!0;if("CallExpression"!==f.type)return!1;
f=f.callee;"MemberExpression"!==f.type||"React"!==f.object.name||null==f.property||f.computed||(f=f.property);if("Identifier"!==f.type)return!1;c=c.node.id;f=f.name;if("useRef"===f&&"Identifier"===c.type)return!0;if(("useState"===f||"useReducer"===f)&&"ArrayPattern"===c.type&&2===c.elements.length&&Array.isArray(a.identifiers)){if(c.elements[1]===a.identifiers[0]){if("useState"===f)for(a=a.references,f=0;f<a.length;f++)n.set(a[f].identifier,c.elements[0]);return!0}if(c.elements[0]===a.identifiers[0]&&
"useState"===f)for(a=a.references,c=0;c<a.length;c++)v.add(a[c].identifier)}return!1},z),Z=e(function(a){if(!Array.isArray(a.defs))return!1;a=a.defs[0];if(null==a||null==a.node||null==a.node.id)return!1;var c=a.node,f=B.childScopes;a=null;var b;for(b=0;b<f.length;b++){var d=f[b],g=d.block;if("FunctionDeclaration"===c.type&&g===c||"VariableDeclarator"===c.type&&g.parent===c){a=d;break}}if(null==a)return!1;for(b=0;b<a.through.length;b++)if(c=a.through[b],null!=c.resolved&&C.has(c.resolved.scope)&&!H(c.resolved))return!1;
return!0},I),G=new Map,t=new Map;r(p);G.forEach(function(a,b){var f=a.dependencyNode;a=a.reference.resolved.references;for(var d=!1,g=0;g<a.length;g++){var e=a[g].identifier.parent;if(null!=e&&"MemberExpression"===e.type&&!e.computed&&"Identifier"===e.property.type&&"current"===e.property.name&&"AssignmentExpression"===e.parent.type&&e.parent.left===e){d=!0;break}}d||c({node:f.parent.property,message:"The ref value '"+b+".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy '"+
(b+".current' to a variable inside the effect, and use that variable in the cleanup function.")})});var W=new Set,P=new Set;t.forEach(function(b,d){var f=b.references;b.isStatic&&P.add(d);f.forEach(function(b){b.writeExpr&&(b=b.writeExpr,W.has(d)||(W.add(d),c({node:b,message:"Assignments to the '"+d+"' variable from inside React Hook "+(a.getSource(g)+" will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside ")+
(a.getSource(g)+".")})))})});if(!(0<W.size))if(b){var N=[],M=new Set;"ArrayExpression"!==b.type?c({node:b,message:"React Hook "+a.getSource(g)+" was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."}):b.elements.forEach(function(b){if(null!==b)if("SpreadElement"===b.type)c({node:b,message:"React Hook "+a.getSource(g)+" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."});
else{try{var d=Y(b)}catch(V){if(/Unsupported node type/.test(V.message)){"Literal"===b.type?t.has(b.value)?c({node:b,message:"The "+b.raw+" literal is not a valid dependency because it never changes. Did you mean to include "+(b.value+" in the array instead?")}):c({node:b,message:"The "+b.raw+" literal is not a valid dependency because it never changes. You can safely remove it."}):c({node:b,message:"React Hook "+a.getSource(g)+" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."});
return}throw V;}for(var f=b;"MemberExpression"===f.type;)f=f.object;var e=!B.through.some(function(a){return a.identifier===f});N.push({key:d,node:b});e||M.add(d)}});var m=ka({dependencies:t,declaredDependencies:N,optionalDependencies:P,externalDependencies:M,isEffect:A});q=m.unnecessaryDependencies;var E=m.missingDependencies,y=m.duplicateDependencies,Q=m.suggestedDependencies;if(0===y.size+E.size+q.size)la({declaredDependencies:N,declaredDependenciesNode:b,componentScope:B,scope:p}).forEach(function(a){var d=
a.fn;a=a.suggestUseCallback;var f="The '"+d.name.name+"' function makes the dependencies of "+(h+" Hook (at line "+b.loc.start.line+") change on every render.");f=a?f+(" To fix this, wrap the '"+(d.name.name+"' definition into its own useCallback() Hook.")):f+(" Move it inside the "+h+" callback. Alternatively, wrap the '"+(d.name.name+"' definition into its own useCallback() Hook."));var e;a&&"Variable"===d.type&&(e=[{desc:"Wrap the '"+d.name.name+"' definition into its own useCallback() Hook.",
fix:function(a){return[a.insertTextBefore(d.node.init,"useCallback("),a.insertTextAfter(d.node.init,")")]}}]);c({node:d.node,message:f,suggest:e})});else{!A&&0<E.size&&(Q=ka({dependencies:t,declaredDependencies:[],optionalDependencies:P,externalDependencies:M,isEffect:A}).suggestedDependencies);(function(){if(0===N.length)return!0;var a=N.map(function(a){return a.key}),c=a.slice().sort();return a.join(",")===c.join(",")})()&&Q.sort();m="";if(0<q.size){var R=null;Array.from(q.keys()).forEach(function(a){null===
R&&a.endsWith(".current")&&(R=a)});if(null!==R)m=" Mutable values like '"+R+"' aren't valid dependencies because mutating them doesn't re-render the component.";else if(0<M.size){var K=Array.from(M)[0];p.set.has(K)||(m=" Outer scope values like '"+K+"' aren't valid dependencies because mutating them doesn't re-render the component.")}}if(!m&&E.has("props")){p=t.get("props");if(null==p)return;p=p.references;if(!Array.isArray(p))return;K=!0;for(var X=0;X<p.length;X++){var O=qa(B.block,p[X].identifier);
if(!O){K=!1;break}O=O.parent;if(null==O){K=!1;break}if("MemberExpression"!==O.type){K=!1;break}}K&&(m=" However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the "+(h+" call and refer to those specific props inside ")+(a.getSource(g)+"."))}if(!m&&0<E.size){var F=null;E.forEach(function(a){if(!F){var c=B.set.get(a),b=t.get(a);if(b.references[0].resolved===c&&(c=c.defs[0],null!=c&&null!=c.name&&"Parameter"===c.type)){c=!1;for(var d,
f=0;f<b.references.length;f++)if(d=b.references[f].identifier,null!=d&&null!=d.parent&&"CallExpression"===d.parent.type&&d.parent.callee===d){c=!0;break}c&&(F=a)}}});null!==F&&(m=" If '"+F+"' changes too often, find the parent component that defines it and wrap that definition in useCallback.")}if(!m&&0<E.size){var u=null;E.forEach(function(a){if(null===u)for(var c=t.get(a).references,b,d,f=0;f<c.length;f++){b=c[f].identifier;for(d=b.parent;null!=d&&d!==B.block;){if("CallExpression"===d.type){var e=
n.get(d.callee);if(null!=e){e.name===a?u={missingDep:a,setter:d.callee.name,form:"updater"}:v.has(b)?u={missingDep:a,setter:d.callee.name,form:"reducer"}:(b=c[f].resolved,null!=b&&(b=b.defs[0],null!=b&&"Parameter"===b.type&&(u={missingDep:a,setter:d.callee.name,form:"inlineReducer"})));break}}d=d.parent}if(null!==u)break}});if(null!==u)switch(u.form){case "reducer":m=" You can also replace multiple useState variables with useReducer if '"+(u.setter+"' needs the current value of '")+(u.missingDep+
"'.");break;case "inlineReducer":m=" If '"+u.setter+"' needs the current value of '"+(u.missingDep+"', you can also switch to useReducer instead of useState and read '")+(u.missingDep+"' in the reducer.");break;case "updater":m=" You can also do a functional update '"+u.setter+"("+u.missingDep.substring(0,1)+" => ...)' if you only need '"+u.missingDep+"' in the '"+(u.setter+"' call.");break;default:throw Error("Unknown case.");}}c({node:b,message:"React Hook "+a.getSource(g)+" has "+(l(E,"a","missing",
"include")||l(q,"an","unnecessary","exclude")||l(y,"a","duplicate","omit"))+m,suggest:[{desc:"Update the dependencies array to be: ["+Q.join(", ")+"]",fix:function(a){return a.replaceText(b,"["+Q.join(", ")+"]")}}]})}}else{var U=null;t.forEach(function(a,c){U||a.references.forEach(function(a){if(!U&&n.has(a.identifier)){for(a=a.from;"function"!==a.type;)a=a.upper;a.block===d&&(U=c)}})});if(U){var ea=ka({dependencies:t,declaredDependencies:[],optionalDependencies:P,externalDependencies:new Set,isEffect:!0}).suggestedDependencies;
c({node:g,message:"React Hook "+h+" contains a call to '"+U+"'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass ["+ea.join(", ")+("] as a second argument to the "+h+" Hook."),suggest:[{desc:"Add dependencies array: ["+ea.join(", ")+"]",fix:function(a){return a.insertTextAfter(d,", ["+ea.join(", ")+"]")}}]})}}}}else"useMemo"!==h&&"useCallback"!==h||c({node:g,message:"React Hook "+h+" does nothing when called with only one argument. Did you forget to pass an array of dependencies?"})}
var b=a.options&&a.options[0]&&a.options[0].enableDangerousAutofixThisMayCauseInfiniteLoops||!1,H={additionalHooks:a.options&&a.options[0]&&a.options[0].additionalHooks?new RegExp(a.options[0].additionalHooks):void 0,enableDangerousAutofixThisMayCauseInfiniteLoops:b},k=a.getSourceCode().scopeManager,n=new WeakMap,v=new WeakSet,z=new WeakMap,I=new WeakMap;return{CallExpression:function(b){var d=pa(b.callee,H);if(-1!==d){var e=b.arguments[d],k=b.callee,l=oa(k).name,h=b.arguments[d+1];switch(e.type){case "FunctionExpression":case "ArrowFunctionExpression":g(e,
h,k);return;case "Identifier":if(h&&h.elements&&h.elements.some(function(a){return"Identifier"===a.type&&a.name===e.name}))return;b=a.getScope().set.get(e.name);if(null==b||null==b.defs)return;b=b.defs[0];if(!b||!b.node)break;if("Variable"!==b.type&&"FunctionName"!==b.type)break;switch(b.node.type){case "FunctionDeclaration":g(b.node,h,k);return;case "VariableDeclarator":if(b=b.node.init)switch(b.type){case "ArrowFunctionExpression":case "FunctionExpression":g(b,h,k);return}}break;default:c({node:k,
message:"React Hook "+l+" received a function whose dependencies are unknown. Pass an inline function instead."});return}c({node:k,message:"React Hook "+l+" has a missing dependency: '"+e.name+"'. Either include it or remove the dependency array.",suggest:[{desc:"Update the dependencies array to be: ["+e.name+"]",fix:function(a){return a.replaceText(h,"["+e.name+"]")}}]})}}}}}};
